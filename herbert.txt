Herbert -- a schema notation for EDN

These are just notes to myself.  Probably not useful to anyone else.

Actually, lots of things are wrong in this document, or haven't kept up with the code.

----------------------------------------------------------------------

Movitvations:  want simple language for describing data and function requirements.  Better, more
precise doc.  Also, it can be used for transformations (like XSLT) and validation.

I like to say that Herbert notation is "whiteboard-compatible".

Nice to have bindings like a parser.  But mostly want validation for "shape of data".

But a parser can also give you the parse tree with named bindings which might be useful.  Or maybe
just bindings is good enough since Clojure has lots of ways for transforming the data.

We should restrict ourselves to EDN types.  No records, but you can use the convention that
#my.ns/Rec {:a x :b y} refers to a record my.ns.Rec.  No Java types, but you could maybe use tags
for that as well.  Although, it may be too tricky to impose a convention for language-specific
types.

But really, we won't get any literal tagged values because we have to read that data first.  Use a
default-tagged-value-reader fn to convert all tagged values to a TaggedValue record.  (Also,
override #uuid and #inst -- really should do everything in default-data-readers.)

----------------------------------------------------------------------
Proposed for Clojure conj 2013:

It would be interesting to compare an implementation using core.logic to the squarepeg version.
[org.clojure/core.logic "0.8.3"]





----------------------------------------------------------------------
# Features Implemented and Planned
----------------------------------------------------------------------

* Binding
we want an easy way to bind matches:  (name type)
name must be distinct from types and ops

* Inline sequence -- using (& int sym) notation

* Cross-constraints with bindings
  [(name str) (name2 str) (assert (== (count name) (count name2)))]
  [(name str) (name2 str) (== (count name) (count name2))]

* literals
nil, true, false
:keywords
:ns/kw
'symbols
'ns/symbols
"literal string"
\C

(note -- must quote symbols to get literal treatment)

* wildcard
any -- matches any type

* types (reserved)
bool
str
char
sym
kw
int
float
list
vec
map
set
tag -- NOT IMPL

* synonyms, aliases, NOT IMPL -- should be a predefined map of constraints if you want to use them
long == int
double == float
integer == int
etc.


* regex? -- NOT IMPL by itself, however a (str "regex") constraint is there
Remember regex is not EDN type
#herbert/regex "regex"
(regex "regex") -- instead?

for now, regex arg can be literal string (we call re-pattern) or a clojure regex


* parameterized simple types
(int N M) -- between <= (inclusive?)  -- yes, inclusive
(str "regex") -- 
(sym "regex") -- based on pr-str
(kw "regex")

* operators
(or t1 t2)  -- one element that satisfies either type
(and t1 t2) -- one element that satisfies both types
(not t) -- one element that is not t
(quote X) -- literal, no special interpretation (same as 'X)

* cycles and splices -- notice inline (no explicit collection)
(* t) zero or more
(+ t) one or more
(? t) zero or one
(* t1 t2 t3) -- matches empty, t1 t2 t3 t1 t2 t3 ...
(+ t1 t2 t3) -- matches (non-empty) t1 t2 t3 t1 t2 t3 ...
(? t1 t2 t3) -- matches empty or exactly t1 t2 t3

& for inline ordered elements
  -- at one point was =, but changed to allow = for asserts and readability
(& t1 t2 t3) -- exactly 1 inlined seq of elements, same as (N t1 t2 ... tN) where N=count(ts)


* compact quantifiers for simple names
t* === (* t)
t? === (? t)
t+ === (+ t)

Note: options apply to single type
(int* 10) is same as (* (int 10))

* sequences

(vec t1 t2 ... tN)  -- vector of elements in exact order
(list t1 t2 ... tN)  -- list of elements in exact order
(seq t1 t2 ... tN)  -- seq of elements in exact order
(set t1 t2 ... tN) -- set with all elements, unordered

(vec (* t)) -- vector of any number of t

square brackets match any seq
[t1 t2 t3]  -- any seq (vec or list) containing exactly (t1 t2 t3)
#{t1 t2 t3} -- matches a set with the required elements, others optional

* map
(map kw t .. kwN tN)  -- kw must be present, val must be t
{:a int :b float :c str}  -- literal keys (required) and type exprs

keys can also be literal strings and 'symbols

Question: optional keys?  going with first form -- :a?
{:a? int :b? str}
NOT {:a int? :b str?}

disallowed key -- literally it's optional and must be nil, but effectively disallowed
{:a? nil}


dyvar *constraints*
similar in usage to *data-readers*

Implemented with *constraints* look of sym to var implementing predicate.  Looks at
default-constraints as well.




----------------------------------------------------------------------
# Features OUT
----------------------------------------------------------------------

* No sub-Guards on types  
Make it easy to write a predicate for your exact type.
Allow params to "predicates" (with object x as last arg) for extended options.
For example, I defined odd and even (and (integer? x) (odd? x))

* Clojure destructuring -- NOT DONE, conflicts with other ideas
try to reuse as much as possible
but maybe conflicts with some other notations


* NO on grammar approach.  We're using fns and combinators so just define them with vars.
Maybe later, we could take a map grammar and do the right thing.


* No inline map {t1 t2 .. tN tN+1}  -- all elements in pairwise order

* NO: (underscore) _  match anything and ignore it (multiple _s match independently) -- use "any"
  instead as the type.  Underscore _ can be used as a binding name, doesn't really need special
  treatment.

* DROP leading num support (N t)




----------------------------------------------------------------------
# Sources for Ideas
----------------------------------------------------------------------

Typed Racket has lots of ideas
http://docs.racket-lang.org/ts-guide/types.html

Clojure -- Core.Typed is similar to Typed Racket
https://github.com/clojure/core.typed

Haskell Type notation might be useful or at least a common translation format
http://www.infoq.com/presentations/Type-Functional-Design

Relax/NG
 http://www.relaxng.org/compact-tutorial-20030326.html
 http://infohost.nmt.edu/tcc/help/pubs/rnc/

EDN   https://github.com/edn-format/edn

Look at clj-schema lib:
https://github.com/runa-dev/clj-schema

Nice, new parser lib:
https://github.com/Engelberg/instaparse

Another parser:
https://github.com/mthvedt/clearley

Yet another parser, says it also works with seqs, not just chars
https://github.com/ericnormand/squarepeg

More on parser combinators
http://en.wikipedia.org/wiki/Parser_combinator
http://en.wikipedia.org/wiki/Parsing_expression_grammar
http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators
plus a couple of locally copied papers

Baker "Prag Parsing in Lisp"
http://home.pipeline.com/~hbaker1/Prag-Parse.html

Nippy serialization -- maybe related
https://github.com/ptaoussanis/nippy

but compare to Fressian
https://github.com/Datomic/fressian

----------------------------------------------------------------------

===> SquarePeg looks very promising as a basis for Herbert.  Let's start there.

issue: squarepeg bindings use keywords.  I was planning to use normal Clojure destructuring.  Maybe
use a macro to compile into a let with destructuring?  Actually, square peg can bind to symbols but
the predicates are awkward to write because the only get a one-arg, a map of bindings, so you have
to (get % 'x).  Nicer to read (:x %).  But I overcame this issue with the "assert" feature.

Note that SP rules are greedy and won't backtrack on failure.  Once a subrule succeeds, it's
committed.  That's it.  Some ambiguous `sym? sym int` might fail on a `sym int`, but `sym sym?  int`
would succeed.  Also, you might want something like (or int+ sym+) instead of (or int* sym*) because
the empty match succeeds for int* before it tries any sym.

This is intentional.  See the paper on PEGs. ? * + are greedy.  But you can use & to be
non-greedy.

http://pdos.csail.mit.edu/papers/parsing:popl04.pdf

Remember: no backtracking in SP.  You can look-ahead instead with sp/mknot (as in "not followed
by...")


----------------------------------------------------------------------
Notes

* schema is singular, schemata is plural.

* not based on Frank Herbert, author of Dune, but that would be fun, too.

----------------------------------------------------------------------

Shape of data

Maybe like UML data modeling but simpler and less work.

Idea from Stuart Sierra's strange loop "Functional Design Patterns" talk:  define protocol for
Acceptors.  Then have the data type decide which acceptor to call.  Or maybe have the schema type
decide.  Not sure.

Sierra gave an older talk about the shape of data:

http://www.infoq.com/presentations/Thinking-in-Data


Haskell Pattern Matching

http://www.haskell.org/tutorial/patterns.html

interesting question about lazy patterns, infinite streams and recursive structures


Martin Fowler on schemaless data structures
  conclusion: schemaless => implicit schema (bad), so prefer explicit schemas
http://martinfowler.com/articles/schemaless/
https://www.youtube.com/watch?v=8kotnF6hfd8
http://www.infoq.com/news/2013/04/software-design-21st-century

"schemaless" really means implicit schema
key name accesss defines a "schema" for hashmaps
storage schema vs. predicate schema
contextual validation
implicit schema is bad, hard to find info you need
prefer explicit schema


A response: "Why I like schemaless data structures"
http://www.innoq.com/blog/st/2013/01/why-i-like-schemaless-data-structures/

SEM says: OK so we want a simple notation for an informal schema (required keys for a map, etc.)

Inspiration for notation:
First Clojure/conj C. Grand gave a talk about DSLs.  Using Clojure data structures as the basis for
your DSL rather than inventing new syntax.  Enlive is a good example.
(look up reference)

----------------------------------------------------------------------
implementation approach

currently custom parsing, converted to a squarepeg parser that implements the matching

probably make sense to use squarepeg as the original parser, convert schema to canonical form, and
then to either a squarepeg parser or a logic program


----------------------------------------------------------------------
Why Relax/NG is better than XML-Schemas
http://www.infoq.com/news/2007/10/relaxng
----------------------------------------------------------------------


Relax/NG Compact form in Clojure prefix notation

grammar is a map of {element pattern}
'start' is the reserved name for the starting (root) element of the grammar
elements are just symbols, by convention capitalized
patterns are usually list expressions, but can be predefined symbols

{start AddressBook
 AddressBook (vec (* Card))
 Card (map :name Name :email Email)
 Name (str #"\w")
 Email (str #".*@.*")}

Question:  prefix or postfix * ?
 AddressBook (vec (* Card))
 AddressBook (vec Card*))
 AddressBook [Card*]

for limited numbers:
 AddressBook (vec Card+)
 AddressBook (vec Card?)
 AddressBook (vec (3 Card))
 AddressBook (vec [2 3] Card)
 AddressBook (or (vec 2 Card) (vec 3 Card))

[{:name "Steve" :email "sm@gm.com"} {:name "Lisa" :email "lisa@lm.com"}]


;; vector with an even number of ints
(vec (* int int))

Interleaving (probably not needed as defined in RNC)

RNC external is for including another *.rnc file.  By analogy, we might want to include another
grammar map.  Maybe use @notation?  (or #')?

(def grammar1 '{start AddressBook AddressBook (vec Card) ...})

(def grammar2 '{start {:first str :last str :abk AddrBk}  AddrBk @grammar1})


Extra bonus feature
Nesting names, should follow lexical scope.  (parent Name) allows outer reference if needed

what about a rewrite rule to avoid name clashes? (rename @grammar1 {foo bar baz quux}) or whatever
ns require does?

or just use namespaces properly and there's no conflict?
----------------------------------------------------------------------

Totally wild and mostly separate idea for tagged args: evaluate normally to the arg symbol (so the
compiler doesn't see anything different, but can add assertions when flags set.

(defnx foo [(int x (<= 3 x 10)) (str y)]
  (apply str (repeat x y)))

(defn foo [(int x) (str y)]
  {:pre [(<= 3 x 10)]}
  (apply str (repeat x y)))

(defcon int3t (contype int (<= 3 % 10)))

(defn foo [(int3t x) (str y)]
  (apply str (repeat x y)))

(defn foo [x y]
  {:pre [(and (integer? x) (<= 3 x 10)) (string? y)]}
  (apply str (repeat x y)))


----------------------------------------------------------------------

"Clojure in the Wild Web–7 Reflections"
http://www.infoq.com/presentations/Clojure-ReadyforZero
around 11:00
common bug: non-existent key
----------------------------------------------------------------------

Why I use eval to create the runtime functions

;; example from http://tojava3.appspot.com/question/5080fdf94f1eba38a4dd174e
#_ (defmacro make-primitive-affine-function [t a b]
  (let [cast #(list (symbol (name t)) %)
        x (gensym "x")]
    `(fn [~x] (+ (* ~(cast a) ~(cast x)) ~(cast b)))))

#_ ((make-primitive-affine-function :int 31 47) 5)
; => 202

;; need to use eval
;; http://stackoverflow.com/questions/1824932/clojure-how-to-create-a-function-at-runtime

;; FIXME -- this is dangerous is you allow user-defined guards.  They could (launch-missiles)!
;; We should define allowed functions and audit the guard code.
(defn runtime-fn [arg expr]
  (eval `(fn [~arg] ~expr)))

----------------------------------------------------------------------
so what about #{set} notation for any order but all required?
actually, handle it like a map but just keys
must be a set
set as whole must satisfy all of the contained expressions

makes sense with literals
more complicated with types

#{int*}  -- any number of ints
#{int sym} -- one int and one sym, or at least one?
#{:a :b :c} -- exact literals
#{int* sym?} -- any number of ints, zero or one sym -- but really not constrained

means that other things are also allowed unless you say (and (not #{:c}) #{:a :b})

compile #{(not foo) x y}  ---> (and #{x y} (not #{foo}))

also has implications for maps when you handle other key types
you could say that just literal keys are allowed for literal {} and #{}

sort constraints:
literals -- exact match, one rule per lit or combine into a set and check intersection
singles -- one rule per single, test every element so that it matches at least one rule
	one element could actually match more than one rule
multiples  -- one multiple means every element matches the single version of the rule

A set may contain other things so we don't want to say every element must match some rule.
Every rule must match some element? Even the same one?

Really, int* doesn't constrain much since zero is easy.  int+ isn't much different from int.  So
let's say * and ? items dropped completely and + is just the same as base.

Allow one multiple int* to mean only ints.  int+ one or more but only ints

#{int*} -- a set of ints and nothing but ints
#{int+} -- a set of one or more ints, nothing else
#{int?} -- a set of one int or empty


;; a mixed set of ints or syms
#{(* (or int sym))}  -- or something like #{isym*}

literals are required, but others OK
#{:a "foo" 10}  -- required elements 


use same interpretation for a map (keys c c2...)

----------------------------------------------------------------------

Issue: what about (* int*)  -- should be same as int*
quantifier ops should simple-sym their underlying types
(* (or int* sym*))  -- same as (* (or int sym))

probably should be an error to mix qsyms with qop

----------------------------------------------------------------------
Maybe should predefine all int*, etc. rather than runtime computation.  But "runtime" isn't
necessarily bad since you can "compile" the constraint fns with (conforms? con)

Guards on quantified types?
  apply per element?  -- no
  apply to whole matching collection? -- seems fair

:step two-arg function applies to previous and current
:step inc
first element is initial value, untested

(ints* :when <) -- 3 4 5
(inst* :step inc)

but that's inconsistent with explicit naming of args

(ints* ns :when (apply < ns)) -- 3 4 5

(ints* [n & more :as ns] :step (inc n))

(* int int int)
----------------------------------------------------------------------

;; tests if coll matches the result of (take (count coll) (iter f (first coll)))

(defn iter1? [f coll]
  (reduce (fn [cur x] (if (= x (f cur)) x (reduced false)))
            (first coll)
	    (rest coll)))

(defn iter? [f coll]
     (= coll (take (count coll) (iterate f (first coll)))))

(int* :iter inc)
(int* >)

(int* :step 3)   matches [4 7 10]

(int :in [0 10])
(int :in #{7 11})
(int :in 10)
(str :in "regex")
(str :in ["a" "m"])   -- any first letter between "a...m"
(str :in ["AAA" "zzz"])   -- any first three letter between "AAA...zzz"  (< upper lower)

(sym :in #{foo bar baz})


New syntax for (list expr)
first item is the type descriptor
second+ symbols name predicates (even? odd? etc)
at end of list can be kw + single args

(defn dplus [x] (* 2 (inc x)))


(int :in val)  -- inclusive between (implemented as protocol)
(vec :as v)  -- bind match to symbol
(int* :step 3)  -- matching ints should be +3 apart (like range assuming first int is start)
(int* :iter dplus) -- matches if iterate over fn would produce the elements, first is start

(type pred1 :in literal :as bind)
(int* pred :step 3)

(int* :iter dplus)

(int* :iter dec)  ===> (10 9 8 7)
(int* :step -1)  ===> (10 9 8 7)

(int :is (+ 3 n))
(int :is (plus3 n))  -- not predicate but function result, tested with =, n from previous binding

:is vs. :as -- easy typo
:=

(int :is (+ 3 n))
(int := (+ 3 n))
(int = (+ 3 n))
(int :in #{(+ 3 n)})

maybe cross item constraint should be a separate expression -- YES, implemented

(& (n odd) (m even) (assert (> n m)))

----------------------------------------------------------------------

Bug with quants
(int* :step 3)  was looking like (* (int :step 3))
should be ((* int) :step 3)

but even with the second one the step function is getting called with an empty input

(int* even?)  could be (* (int even?))
vs. (int* :every even?)

(def even (tconstraint '(int even?)))

----------------------------------------------------------------------

Clearly kw args, like :step, :iter, :as should apply to whole collection
:in is a toss up.

Simple rule is that guards apply to whole collection.

But the more practical idea is to bind guards to the base type and the kw args to the collection.

(def pair (tconstraint '(& kw int)))

----------------------------------------------------------------------

Use `name` with no type as a constraint to be exactly the same as a previous binding for name.

[(a int) a a]  matches [3 3 3], [4 4 4], etc.

Also a+ etc will work.



----------------------------------------------------------------------
# Ideas
----------------------------------------------------------------------


Need a macro that "pre-compiles" constraint for better performance at runtime.
----------------------------------------------------------------------
test with records -- it would be nice if {:a int} worked as well -- looks like it does
----------------------------------------------------------------------
Idea: notation for fn specs, basically like fn declaration, but add return type at end
(fn fname [arg arg2] return)

(fn fname ([arg1] return1) ([arg1 arg2] return2) ...)

Issue: how does destructuring play with Herbert schemas.  Doesn't sound very promising.

----------------------------------------------------------------------
generative testing connection

https://github.com/clojure/test.generative
http://www.infoq.com/presentations/Clojure-Generative-Testing

also consider contracts libs
trammel and core.contracts

http://www.json-generator.com/

Something like this for Herbert. 

----------------------------------------------------------------------
"Addressable" values

Nested key paths
Ordinals
Named bindings

Like xpath

----------------------------------------------------------------------
"loose" schema comment by cgrand

cgrand mentions "loose schema" in reference to clj-schema.  The point is to allow extra stuff
strict schema would be less flexible

http://grokbase.com/t/gg/clojure/12bsnsv82w/ann-clj-schema-schemas-for-clojure-maps 


Hi Alex,

To echo Laurent's concern: if you use schema to validate inputs you get
from another (sub)system then, in my opinion, a loose schema is a better
fit.
It's the must-understand/must-ignore schism once again.
Must-ignore (loose schemas) requires care when revising a schema (since any
piece of data valid under both schemas should not have its semantics
altered) but allows for forward-compatibility and, as such, reduces
coupling.

Regarding your use-case (validation before storing): I see two "complected"
concerns: ensuring that you don't store bad data and ensuring that you
don't store too much. So, couldn't a loose schema be sued to first validate
the piece of data and then (or at the same time) prune extra keys?

My two cents,

Christophe

----------------------------------------------------------------------

Choosing the right data type
http://cemerick.com/2011/07/05/flowchart-for-choosing-the-right-clojure-type-definition-form/

----------------------------------------------------------------------

ideas:  do you want a projection/filter from one spec to another?
diff specs?  (ala clojure.data/diff)

----------------------------------------------------------------------

direct instance test
anything with a dot could be a class, test with (instance? dot.type)
anything with a capital?  Integer Long etc
anything starting with a ^Integer, like a type tag meta notation -- doesn't work
explicitly:  (type java.lang.Integer)

----------------------------------------------------------------------

use a parser on the constraint spec 
write a grammar for your scema lang
use a formal AST derived from Herbert notation
analogy: Relax/NG XML vs. Compact

----------------------------------------------------------------------
Datomic -- we should be able to create datomic schemas from Herbert constraints.

http://blog.markwatson.com/2012/07/a-little-clojure-wrapper-for-datomic/

boiler plate for attributes
https://gist.github.com/rodnaph/5694439

http://www.lispcast.com/the-datomic-architecture-and-data-model

Rich Hickey: " This is not a schemaless system. There's no such thing as a schemaless system. There
are systems where you write your schema down and ones where you don't. There's no such thing as a
schemaless database. So we do require you to be explicit about this part of your database."

Eric Normand: The issue is not whether a database needs an explicit schema. The issue is whether the
language you write down your schema in can express the data model you would like to use.  That said,
the Datomic schemas, along with the "datom" model, do look expressive.

http://docs.datomic.com/schema.html







----------------------------------------------------------------------
# Issues
----------------------------------------------------------------------


If you need a huge number in a row, could use an explicit (repeat N t), but most of the time it's
workable to just list out the constraint N times

----------------------------------------------------------------------

Issue: versions and migration of data
version numbers?

micro-format for edn?  It's schemaless by design, but something to identify a format version might
be useful.  Same could be said for Herbert schemas.  On the other hand, adds weight and it's hard to
see how Clojure datatypes will change much (in a non-compatible way).
----------------------------------------------------------------------

pragmatic decision:
optional keys should imply nil is OK value
:k? int   ==> :k? (or int nil)

not normally useful (maybe could have special secret meaning)
:k* int   ==> :k? int
:k+ int   ==> :k int

but only for explicit keys
(? int) does not imply nil is OK
----------------------------------------------------------------------

some of this might apply to Herbert for XSLT-like stuff

http://www.slideshare.net/tomfaulhaber/split-applycombine20130606 

https://github.com/tomfaulhaber/split-apply-combine
----------------------------------------------------------------------
Question: allow doc-string on elements or comments wherever?

----------------------------------------------------------------------
bug: need to clean up reserved-ops vs. constraint keys

issue: extensibility for ops.  How can the user create a new collection?  Say a queue with element
constraints.  Basic constraint types work with *constraints* and a user-defined predicate that can
take args so those args could be the type constraints.  So the implementation needs to call into
herbert to hand those constraints, probably with conforms?.  Guess it would work.  Why not handle
seq and vec that way, in the base implementation?

Maybe use (resolve (add-qmark sym)) to find the predicate in the current ns.  Should work but is
that strange to have a different mechanism?

Issue: missing named patterns.  Need to write your own predicate.
----------------------------------------------------------------------

Need to consider nested binding names in quantifiers.  Only makes sense to bind at top level if
there may be multiple matches.  Currently, last one probably wins.

----------------------------------------------------------------------

drop the :as binding, just use the prefix form (foo int)

define some constants like MAX_INT for param constraints

Issue: what about sorted-maps and sets?  Not EDN


----------------------------------------------------------------------

DROP THESE:
(N t) exactly N  -- should drop this
([M N] t)  between M and N (inclusive)  -- should drop this

(N t1 t2 t3) -- exactly N total elements, cycling through types

I think we should drop the N and [M N] ops, not really needed

Note:  maybe should remove the Numbered quantifier -- not sure if it's worth the complexity?
Especially with the multiple items: is the count total elements or cycles?

If N is * then any length is allowed. Also, + and ?, and [N M]. 
[N] means N or more  (sort of like [N *] but that's not used

----------------------------------------------------------------------
Dropped
(keys :a :b :c) -- required keys, but others allowed, except for (not :x)

----------------------------------------------------------------------
Issue: consider dropping undocumented features
  :as -- I think so, better to use binding names
  :in -- kind of useful but is there a better way? 
      -- numbers handled by param, stringish by regex
  :step and :iter seem useful
